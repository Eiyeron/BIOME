#include <fxcg/display.h>
#include <fxcg/keyboard.h>
#include "RTC_syscalls.h"
#include <stdlib.h>
#include "graphics.h"
#include "engine.h"

int KeyDown(int basic_keycode)
{
	const unsigned short* keyboard_register = (unsigned short*)0xA44B0000;
	int row, col, word, bit;
	row = basic_keycode%10;
	col = basic_keycode/10-1;
	word = row>>1;
	bit = col + 8*(row&1);
	return (0 != (keyboard_register[word] & 1<<bit));
}

static unsigned int lastrandom=0x12345678; 
unsigned int srandom(int seed){ 
	if (seed) lastrandom=seed; 
	lastrandom = ( 0x41C64E6D*lastrandom ) + 0x3039; 
	return ( lastrandom >> 16 ); 
} 
unsigned int random(void) { 
	return srandom(0); 
} 


void WW_load_settings(settings* sets) {
	sets->sim_type = WW;
	sets->col_num = 4;

	//defaults color parameters
	sets->cells_col = malloc(sizeof(unsigned short) * 4);
	sets->cells_col[VOID] = COLOR_BLACK;
	sets->cells_col[WIRE] = COLOR_WHITE;
	sets->cells_col[ELEC_HEAD] = COLOR_LIGHTBLUE;
	sets->cells_col[ELEC_TAIL] = COLOR_NAVY;
	
}

void GoL_load_settings(settings* sets) {
	sets->sim_type = GOL;
	sets->col_num = 2;
	
	
	for(int i =0; i< 9; i++) {
		sets->gol_neighbour_num_born[i] = 0;
		sets->gol_neighbour_num_survive[i] = 0;
	}
	//default Game of Life parameters
	sets->gol_neighbour_num_survive[2] = 1;
	sets->gol_neighbour_num_survive[3] = 1;		
	sets->gol_neighbour_num_born[3] = 1;
	
	//defaults color parameters
	sets->cells_col = malloc(sizeof(unsigned short) * 2);
	sets->cells_col[0] = COLOR_BLACK;
	sets->cells_col[1] = COLOR_WHITE;
	
}

void WW_reaction(unsigned char* topTable, unsigned char* backTable, settings sets) {
	for(int i =0; i< sets.height; i++) {
		for(int j = 0; j< sets.width; j++) {
			unsigned char currentCell = backTable[i*sets.width + j];

			//counting alive neighbours
			unsigned char aliveTotal = 0; // alive neighbours
			if(i > 0) { //top
				aliveTotal += (j > 0 && backTable[(i-1)*sets.width + j-1] == ELEC_HEAD); //TL
				aliveTotal += (backTable[(i-1)*sets.width + j] == ELEC_HEAD); //T
				aliveTotal += (j < sets.width - 1 && backTable[(i-1)*sets.width + j+1] == ELEC_HEAD); //TR
			}
			aliveTotal += (j > 0 && backTable[i*sets.width + j-1] == ELEC_HEAD); //L
			aliveTotal += (j < sets.width - 1 && backTable[i*sets.width + j+1] == ELEC_HEAD); //R
			if(i < sets.height) { //bottom
				aliveTotal += (j > 0 && backTable[(i+1)*sets.width + j-1] == ELEC_HEAD); //DL
				aliveTotal += (backTable[(i+1)*sets.width + j] == ELEC_HEAD); //D
				aliveTotal += (j < sets.width - 1 && backTable[(i+1)*sets.width + j+1] == ELEC_HEAD); //DR
			}

			//doing the wire thing
			switch(currentCell) {
			case ELEC_HEAD:
				currentCell = ELEC_TAIL;
				break;
			case ELEC_TAIL:
				currentCell = WIRE;
				break;
			case WIRE:
				currentCell = (aliveTotal == 1 || aliveTotal == 2)? ELEC_HEAD : WIRE;
				break;
			}
			
			//putting the result in the top table
			topTable[i*sets.width + j] = currentCell;
		}
	}
}

void GoL_reaction(unsigned char* topTable, unsigned char* backTable, settings sets) {
	for(int i =0; i< sets.height; i++) {
		for(int j = 0; j< sets.width; j++) {
			unsigned char currentCell = backTable[i*sets.width + j];

			//counting alive neighbours
			unsigned char aliveTotal = 0; // alive neighbours
			if(i > 0) { //top
				aliveTotal += (j > 0 && backTable[(i-1)*sets.width + j-1]); //TL
				aliveTotal += (backTable[(i-1)*sets.width + j] != 0); //T
				aliveTotal += (j < sets.width - 1 && backTable[(i-1)*sets.width + j+1]); //TR
			}
			aliveTotal += (j > 0 && backTable[i*sets.width + j-1]); //L
			aliveTotal += (j < sets.width - 1 && backTable[i*sets.width + j+1]); //R
			if(i < sets.height) { //bottom
				aliveTotal += (j > 0 && backTable[(i+1)*sets.width + j-1]); //DL
				aliveTotal += (backTable[(i+1)*sets.width + j] !=0); //D
				aliveTotal += (j < sets.width - 1 && backTable[(i+1)*sets.width + j+1]); //DR
			}

			//doing the alive/dead job
			if(currentCell != 0) {
				currentCell = sets.gol_neighbour_num_survive[aliveTotal];
			}
			else {
				currentCell = sets.gol_neighbour_num_born[aliveTotal];
			}
			
			//putting the result in the top table
			topTable[i*sets.width + j] = currentCell;
		}
	}
}

void engine(settings sets) {
	unsigned char done = 0;
	unsigned char* topTable;
	unsigned char* backTable;
	unsigned char* tableA = (unsigned char*)(malloc(sizeof(unsigned char) * sets.width * sets.height));
	unsigned char* tableB = (unsigned char*)(malloc(sizeof(unsigned char) * sets.width * sets.height));
	
	
	srandom(RTC_GetTicks());
	unsigned int numCells = sets.width*sets.height;
	for(unsigned int i =0; i<numCells; i++) {
		tableB[i] = random()%2;
		tableA[i] = tableB[i];
	}
	
	topTable = tableA; backTable = tableB;
	
	int decal = 0;
	int menu_vy = 0;
	while(!done) {
	
		if(KeyDown(68)) {//OPTN
			if(decal == 0)
				menu_vy = 2;
			else if(decal == 10)
				menu_vy = -2;
		}
		decal+= menu_vy;
		if(decal == 0 || decal == 10)
			menu_vy = 0;
		
		if(decal == 10)
			UI(&sets, topTable, backTable);
		
		if(KeyDown(47))
		done = 1;
		
		//switching tables
		unsigned char* temp;
		temp = backTable;
		backTable = topTable;
		topTable = temp;
		
		//operating
		switch(sets.sim_type) {
		case GOL:
			GoL_reaction(topTable, backTable, sets);
			break;
		case WW:
			WW_reaction(topTable, backTable, sets);
			break;
			
		}
		
		//drawing
		Bdisp_AllClr_VRAM();
		Bdisp_EnableColor(1);
		draw_grid(topTable, sets);
		drawMenu(decal);
		Bdisp_PutDisp_DD();	
		
	}
	
	free(tableA);
	free(tableB);
	
}

void drawMenu(int decal) {
	const unsigned short Menu_palette[2] = {0x0000, 0xffff};

	const unsigned char Menu[480] = {
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xfe,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xfe,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xfe,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xfe,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xfe,0x7f,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
		0x83,0x05,0xd0,0xe3,0x74,0x18,0xc1,0x0e,0x82,0xf8,0x20,0x83,0x00,0x00,0x00,0x02,0x82,0x18,0x20,0x82,0xe8,0x3f,0xff,0x02,0x82,0x0b,0xb8,0x2e,0xbe,0x08,0x39,0x26,0x82,0x0b,0xa0,0xfa,0xf8,0x20,0x87,0xfe,0x41,0x04,0x10,0x41,0x74,0x10,0x70,0x03,
		0xbb,0x74,0xd7,0x4d,0x37,0x77,0xdf,0x76,0xbe,0xfb,0xee,0xbb,0x7f,0xff,0xe6,0xe2,0xbe,0xee,0xfb,0xee,0x6b,0xff,0xff,0x82,0xbf,0xb9,0x3b,0xae,0xbe,0xfb,0xf9,0x26,0xbe,0xeb,0xaf,0xf6,0xfb,0xae,0xbb,0x86,0x5f,0x7f,0x7d,0xf7,0x35,0xf7,0xef,0xfd,
		0xbb,0x74,0xd7,0x5d,0x27,0x7b,0xdf,0x76,0xbe,0xfb,0xee,0xbb,0x7f,0xff,0xdf,0x6a,0xbe,0xee,0xfb,0xee,0xab,0xff,0xff,0xc2,0xbf,0xba,0xbb,0xae,0xbe,0xfb,0xff,0xfe,0xbe,0xeb,0xaf,0xf6,0xfb,0xae,0xbb,0xba,0x5f,0x7f,0x7d,0xf7,0x55,0xf7,0xf0,0x03,
		0xbb,0x35,0x57,0x5d,0x57,0x78,0xef,0x66,0xbe,0xf8,0x6e,0x83,0x7f,0xfd,0x8d,0x82,0x86,0xee,0xfb,0xee,0xcb,0xff,0xff,0x82,0x83,0xbb,0xb8,0x2e,0xbe,0x18,0x3f,0xe6,0x82,0x0b,0xa1,0xee,0xfb,0xa0,0xbb,0x82,0x41,0x1f,0x7d,0xf7,0x65,0xf0,0x7f,0xff,
		0xa7,0x45,0x57,0x5d,0x76,0xff,0x67,0x0e,0xbe,0xfb,0xe0,0xb7,0x7f,0xfc,0x1c,0xc2,0xbe,0xee,0xfb,0xee,0xeb,0x3f,0xff,0x12,0xfb,0xbb,0xbb,0x6e,0xbe,0xff,0xbf,0xe6,0xfa,0xeb,0xaf,0xee,0xfb,0xae,0xbb,0x82,0x7d,0x7f,0x7d,0xf7,0x75,0x1f,0x70,0x1b,
		0x97,0x75,0x97,0x5d,0x76,0xfe,0xef,0x6e,0xbe,0xfb,0xee,0xb7,0x7f,0xfe,0x94,0x02,0xbe,0xee,0xfb,0xee,0xeb,0xbf,0xfe,0x3a,0xfb,0xbb,0xbb,0xae,0xbe,0xff,0xbf,0xfe,0xfa,0xeb,0xaf,0xde,0xfb,0xae,0xbb,0x82,0x7d,0x7f,0x7d,0xf7,0x75,0xdf,0x6f,0xe1,
		0xbb,0x75,0x96,0x45,0x76,0xfe,0x5f,0x76,0xbe,0xfb,0xee,0xbb,0x7f,0xfe,0x90,0x02,0xbe,0xee,0xfb,0xee,0xeb,0xbf,0xfc,0x7e,0xfb,0xbb,0xbb,0xae,0xbe,0xff,0xbf,0x3e,0xfa,0xed,0x6f,0xde,0xfb,0xae,0xbb,0x82,0x7d,0x7f,0x7d,0xf7,0x75,0xdf,0x70,0x1b,
		0xbb,0x75,0xd1,0xfb,0x74,0x10,0xc1,0x76,0x82,0x08,0x2e,0xbb,0x00,0x00,0x00,0x02,0x82,0x18,0x3b,0x82,0xe8,0x3f,0xf8,0xfe,0x82,0x0b,0xbb,0xa0,0x82,0x08,0x3f,0x3e,0x82,0xee,0xe0,0xbe,0x08,0x2e,0x87,0xfe,0x41,0x07,0x7d,0xc1,0x74,0x10,0x7f,0xff
	};
	
	CopySpriteNbit(Menu, 0, LCD_HEIGHT_PX-decal, 384, 10, Menu_palette, 1);

	
}

void UI(settings* sets, unsigned char* topTable, unsigned char* backTable) {
	unsigned int numCells = sets->width*sets->height;
	if(KeyDown(79)) {
		for(int i = 0; i<numCells; i++) {
			topTable[i] = random()%2;
			backTable[i] = topTable[i];
		}
	}
	else if(KeyDown(69)) {
		for(int i = 0; i<numCells; i++) {
			topTable[i] = 0;
			backTable[i] = 0;
		}
	}
	else if(KeyDown(59)) {
		editRules(sets);
	}
}

void showColors(settings* sets) {
	const unsigned short nb_p[2] = {0x0000, 0xffff};
	
	const unsigned char Colors[112] = {
		0x00,0x3f,0xff,0xff,0xff,0xff,0xfc,
		0x00,0x3f,0xff,0xff,0xff,0xff,0xfc,
		0x3f,0xff,0xff,0xff,0xff,0xff,0xfc,
		0x3f,0xff,0xff,0xff,0xff,0xff,0xfc,
		0x3f,0xff,0xfc,0xff,0xff,0xff,0xfc,
		0x3f,0xff,0xfc,0xff,0xff,0xff,0xfc,
		0x3f,0xff,0xfc,0xff,0xff,0xff,0xfc,
		0x3f,0xff,0xfc,0xff,0xff,0xff,0xfc,
		0x3f,0xf0,0x0c,0xc0,0x30,0x0c,0x00,
		0x3f,0xf0,0x0c,0xc0,0x30,0x0c,0x00,
		0x3f,0xf3,0xcc,0xcf,0x33,0xcc,0x3c,
		0x3f,0xf3,0xcc,0xcf,0x33,0xcc,0x3c,
		0x3f,0xf3,0xcc,0xcf,0x33,0xff,0xc0,
		0x3f,0xf3,0xcc,0xcf,0x33,0xff,0xc0,
		0x00,0x30,0x0c,0xc0,0x33,0xfc,0x00,
		0x00,0x30,0x0c,0xc0,0x33,0xfc,0x00
	};//54*16
	CopySpriteNbit(Colors, 0,0, 54,16, nb_p, 1);
	for(int i =0; i< sets->col_num; i++) {
		Rectangle(18 + 20*i, 18, 32 + 20*i, 32, 1, COLOR_BLACK);
		Filled_Rectangle(20 + 20*i, 20, 30 + 20*i, 30, sets->cells_col[i]);
	}
}

void GoL_showRules(settings* sets) {
	const unsigned short nb_p[2] = {0x0000, 0xffff};

	const unsigned char Alive[96] = {
			0x00,0x0f,0xff,0xff,0xff,0xff,
			0x00,0x0f,0xff,0xff,0xff,0xff,
			0x3f,0xcf,0xff,0xff,0xff,0xc3,
			0x3f,0xcf,0xff,0xff,0xff,0xc3,
			0x3f,0xcc,0xff,0xff,0xff,0xc3,
			0x3f,0xcc,0xff,0xff,0xff,0xc3,
			0x3f,0xcc,0xff,0xff,0xff,0xff,
			0x3f,0xcc,0xff,0xff,0xff,0xff,
			0x00,0x0c,0xcc,0xf3,0x00,0xff,
			0x00,0x0c,0xcc,0xf3,0x00,0xff,
			0x3f,0xcc,0xfc,0xf3,0x0f,0xc3,
			0x3f,0xcc,0xfc,0xf3,0x0f,0xc3,
			0x3f,0xcc,0xcc,0xf3,0x3f,0xc3,
			0x3f,0xcc,0xcc,0xf3,0x3f,0xc3,
			0x3f,0xcc,0xcf,0x0f,0x00,0xff,
			0x3f,0xcc,0xcf,0x0f,0x00,0xff
		};//48*16

	const unsigned char Surv[96] = {
		0x00,0x0f,0xff,0xff,0xff,0xff,
		0x00,0x0f,0xff,0xff,0xff,0xff,
		0x3f,0xff,0xff,0xff,0xff,0xf0,
		0x3f,0xff,0xff,0xff,0xff,0xf0,
		0x3f,0xff,0xff,0xff,0xff,0xf0,
		0x3f,0xff,0xff,0xff,0xff,0xf0,
		0x00,0x0f,0xff,0xff,0xff,0xff,
		0x00,0x0f,0xff,0xff,0xff,0xff,
		0xff,0xcc,0xf3,0x00,0xcf,0x3f,
		0xff,0xcc,0xf3,0x00,0xcf,0x3f,
		0xff,0xcc,0xf3,0x3c,0xcf,0x30,
		0xff,0xcc,0xf3,0x3c,0xcf,0x30,
		0xff,0xcc,0xf3,0x3f,0xcf,0x30,
		0xff,0xcc,0xf3,0x3f,0xcf,0x30,
		0x00,0x0c,0x03,0x3f,0xf0,0xff,
		0x00,0x0c,0x03,0x3f,0xf0,0xff
	};//48*16
	CopySpriteNbit(Alive, 0,74, 48, 16, nb_p,1);
		CopySpriteNbit(Surv, 0,146, 48, 16, nb_p,1);

	for(int i = 0; i<9; i++) {
		unsigned char str[] = "\xE7\x2F";//little num chars
		str[1] = 0x30+i;
		unsigned char check[] = "\xE6\xA5"; //Check box

		locate_OS(i+4,3);
		check[1] = sets->gol_neighbour_num_survive[i]? 0xA9 : 0xA5;
		Print_OS(check, TEXT_MODE_NORMAL, 0);
		locate_OS(i+4,4);
		Print_OS(str, TEXT_MODE_NORMAL, 0);
	
		locate_OS(i+4,6);
		check[1] = sets->gol_neighbour_num_born[i]? 0xA9 : 0xA5;
		Print_OS(check, TEXT_MODE_NORMAL, 0);
		locate_OS(i+4,7);
		Print_OS(str, TEXT_MODE_NORMAL, 0);
	}
	showColors(sets);
}

void GoL_editRules(settings* sets) {


	
	unsigned char cursor_y = 0;
	unsigned char cursor_x = 0;
	while(!KeyDown(31)){
		if(KeyDown(28) && cursor_y){//up
			if(cursor_y == 1)
				cursor_x = 0;
			cursor_y--;
		}
		if(KeyDown(37) && cursor_y < 2) {//down
			if(cursor_x == 0)
				cursor_x = 0;
			cursor_y++;
		}
		if(KeyDown(38) && cursor_x) {//left
			cursor_x--;
		}
		if(KeyDown(27) && cursor_x < (cursor_y == 0 ? sets->col_num -1 : 8)) {//right
			cursor_x++;
		}
	
		if(KeyDown(78)) {
			switch(cursor_y) {
				case 0:
				break;
				
				case 1:
				sets->gol_neighbour_num_survive[cursor_x] ^= 1;
				break;
				
				case 2:
				sets->gol_neighbour_num_born[cursor_x] ^= 1;
				break;
			}
		}
	
		GoL_showRules(sets);
		if(cursor_y == 0) {
			Rectangle(18 + 20*cursor_x, 18, 32 + 20*cursor_x, 32, 1, COLOR_RED);
		}else{
			unsigned char check[] = "  \xE6\xA5"; //Check box
			unsigned char box = cursor_y == 1 ?sets->gol_neighbour_num_survive[cursor_x] : sets->gol_neighbour_num_born[cursor_x];
			check[3] = box? 0xA9 : 0xA5;

			PrintXY( cursor_x+4, 3*cursor_y, check, TEXT_MODE_NORMAL, TEXT_COLOR_RED );
			Print_OS(check, TEXT_MODE_NORMAL, TEXT_COLOR_RED);
		}


		Bdisp_PutDisp_DD();
		int time = RTC_GetTicks();
		while(RTC_GetTicks() - time < 16);
	}
	
}

void WW_showRules(settings* sets) {


}

void editRules(settings* sets) {


	Bdisp_AllClr_VRAM();
	Bdisp_EnableColor(1);

	switch(sets->sim_type) {
	case GOL:
		GoL_editRules(sets);
	case WW:
		WW_showRules(sets);
	
	}

}

void draw_grid(unsigned char* grid, settings sets) {

	for(int i=0; i<sets.height; i++) {
		for(int j=0; j<sets.width; j++) {
			unsigned short val = sets.cells_col[grid[i*sets.width + j]];
			unsigned short jt = j<<1;
			unsigned short it = i<<1;
			SetPixel(jt,it, val);
			SetPixel(jt,it+1, val);
			SetPixel(++jt,it, val);
			SetPixel(jt,it+1, val);
		}
	}

}
